/****************************************************************************\ 
 *** 
 *** File                  : fm_entry_ap.cpp
 *** 
 *** Generated by dSPACE Tools.
 *** (c) Copyright 2013, dSPACE GmbH. All rights reserved.
\****************************************************************************/

#if !defined(FM_ENTRY_AP_CPP_)
#  define    FM_ENTRY_AP_CPP_


/* -- Include directives. -- */
#  include "IOCode_Data.h"
#  include <DsApplicationInterface.h>
#  include "fm_entry_ap.h"

#  if defined(EXTERN_C_DECL)
#    undef EXTERN_C_DECL
#  endif
#  if defined(__cplusplus)
#    define EXTERN_C_DECL extern "C"
#  else
#    define EXTERN_C_DECL extern
#  endif


/* -- Variable declarations in module scope. -- */

/* Pragma to suppress GCC stack reuse which leads to problems with signal chain code */
#ifdef __GNUC__
#pragma GCC optimize "-fstack-reuse=none"
#endif

/* -- Definitions of exported functions. -- */

  void
ap_entry_RS_DS_CM11_SimulinkRS_SIDS1_TID1(
    void) 
{
    rs_ds_cm11_simulinkrs_fcnModule_SIDS1_TID1->updateInputs();
{
tCP_1_ConnectionState = pTCP_1_DriverHandle->getConnectionState(ErrorList);
}
{
int numOfReceivedBytes = 0;
tCP_1_NumOfReceivedBytes = numOfReceivedBytes;
tCP_1_Receive_Status = 0;
int bytesToReceive = 0;
tCP_1_ConnectionState = pTCP_1_DriverHandle->getConnectionState(ErrorList);
if (tCP_1_ConnectionState == TCP_CONNECTION_CONNECTED)
{
bytesToReceive = tCP_1_Receive_DataSize;
numOfReceivedBytes = pTCP_1_DriverHandle->recv(ErrorList, &tCP_1_SocketData2Recv);
/* Check for valid data */
if (numOfReceivedBytes >= 0)
{
/* Check if there is enough space in the receive buffer */
if (tCP_1_ReceiveBufferFreeBytes >= numOfReceivedBytes)
{
/* Successfully received data. Write data into the receive buffer */
std::memcpy((void *)(pTCP_1_ReceiveBuffer + (tCP_1_ReceiveBufferSize - tCP_1_ReceiveBufferFreeBytes)), tCP_1_SocketData2Recv.data, numOfReceivedBytes);
/* Decrease the number of free space in the receive buffer */
tCP_1_ReceiveBufferFreeBytes = tCP_1_ReceiveBufferFreeBytes - numOfReceivedBytes;
/* Check if the receive buffer stores the required amount of data */
if ((tCP_1_ReceiveBufferSize - tCP_1_ReceiveBufferFreeBytes) >= bytesToReceive && bytesToReceive > 0 && bytesToReceive <= 1024)
{
/* Copy receive buffer data to the Data Vector outport */
std::memcpy(tCP_1_Receive_DataVector, (void *)pTCP_1_ReceiveBuffer, bytesToReceive * (sizeof *tCP_1_Receive_DataVector));
/* Increase the number of free byte in the buffer. By copying more free bytes are available */
tCP_1_ReceiveBufferFreeBytes = tCP_1_ReceiveBufferFreeBytes + bytesToReceive;
/* Check if the receive buffer is not empty */
if (tCP_1_ReceiveBufferFreeBytes < tCP_1_ReceiveBufferSize)
{
/* There is still data in the receive buffer. Copy remaining data to the beginning of the receive buffer */
std::memcpy((void *)pTCP_1_ReceiveBuffer, pTCP_1_ReceiveBuffer + bytesToReceive, tCP_1_ReceiveBufferSize - tCP_1_ReceiveBufferFreeBytes);
}
tCP_1_NumOfReceivedBytes = bytesToReceive;
// success
tCP_1_Receive_Status = 1;
}
/* Set the bytes that are ready to read */
tCP_1_AvailableBytes = tCP_1_ReceiveBufferSize - tCP_1_ReceiveBufferFreeBytes;
if (tCP_1_AvailableBytes < 750000)
{
tCP_1_ReceiveFullBufferErrorFlag = false;
}
}
else
{
if (tCP_1_ReceiveFullBufferErrorFlag == false)
{
msg_warning_printf(0, 0, "TCP (1): Receive buffer is full. Data can no longer be stored. New received data will be lost.");
tCP_1_ReceiveFullBufferErrorFlag = true;
}
}
}
}
}

}

#endif                                 /* FM_ENTRY_AP_CPP_ */
/* [EOF] */
